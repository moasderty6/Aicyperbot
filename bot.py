import os
import asyncio
import json
import aiohttp
from aiogram import Bot, Dispatcher, Router, types
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.enums import ParseMode
from aiogram.fsm.storage.memory import MemoryStorage
from aiohttp import web
from dotenv import load_dotenv
from aiogram.webhook.aiohttp_server import SimpleRequestHandler, setup_application

# ØªØ­Ù…ÙŠÙ„ .env
load_dotenv()

# Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª
API_TOKEN = os.getenv("BOT_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
CHANNEL_USERNAME = "p2p_LRN"
WEBHOOK_HOST = os.getenv("WEBHOOK_HOST")  # Ù…Ø«Ø§Ù„: https://yourapp.onrender.com
WEBHOOK_PATH = f"/webhook/{API_TOKEN}"
WEBHOOK_URL = f"{WEBHOOK_HOST}{WEBHOOK_PATH}"
WEBAPP_HOST = "0.0.0.0"
WEBAPP_PORT = int(os.getenv("PORT", 3000))

# Ø§Ù„Ø¨ÙˆØª
bot = Bot(token=API_TOKEN, parse_mode=ParseMode.MARKDOWN)
dp = Dispatcher(storage=MemoryStorage())
router = Router()
dp.include_router(router)

# Ø¬Ù„Ø³Ø© aiohttp ÙˆØ§Ø­Ø¯Ø© Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
session: aiohttp.ClientSession = None

# Ø§Ù„Ù…ØµØ§Ø¯Ø±
with open('sources.json', encoding='utf-8') as f:
    sources_db = json.load(f)

# ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙƒÙ„Ù…Ø§Øª
keywords_map = {
    "Ø§Ø®ØªØ±Ø§Ù‚": "Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚ Ø§Ù„Ø£Ø®Ù„Ø§Ù‚ÙŠ",
    "penetration": "Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚ Ø§Ù„Ø£Ø®Ù„Ø§Ù‚ÙŠ",
    "Ù‡Ø§ÙƒØ±": "Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚ Ø§Ù„Ø£Ø®Ù„Ø§Ù‚ÙŠ",
    "Ø§Ø®ØªØ¨Ø§Ø±": "Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚ Ø§Ù„Ø£Ø®Ù„Ø§Ù‚ÙŠ",
    "Ø¨Ø±Ù…Ø¬Ø© Ø¢Ù…Ù†Ø©": "Ø§Ù„Ø¨Ø±Ù…Ø¬Ø© Ø§Ù„Ø¢Ù…Ù†Ø©",
    "secure coding": "Ø§Ù„Ø¨Ø±Ù…Ø¬Ø© Ø§Ù„Ø¢Ù…Ù†Ø©",
    "ØªØ´ÙÙŠØ±": "Ø§Ù„ØªØ´ÙÙŠØ±",
    "cryptography": "Ø§Ù„ØªØ´ÙÙŠØ±",
    "Ù‡Ù†Ø¯Ø³Ø© Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠØ©": "Ø§Ù„Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠØ©",
    "social engineering": "Ø§Ù„Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠØ©",
    "ÙÙŠØ±ÙˆØ³": "Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ§Øª Ø§Ù„Ø®Ø¨ÙŠØ«Ø©",
    "malware": "Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ§Øª Ø§Ù„Ø®Ø¨ÙŠØ«Ø©",
    "keylogger": "Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ§Øª Ø§Ù„Ø®Ø¨ÙŠØ«Ø©"
}

def find_topic(text: str):
    text = text.lower()
    for keyword, topic in keywords_map.items():
        if keyword in text:
            return topic
    return None

async def is_subscribed(user_id: int):
    try:
        member = await bot.get_chat_member(f"@{CHANNEL_USERNAME}", user_id)
        return member.status != "left"
    except:
        return False

@router.message(Command(commands=["start", "help"]))
async def start_handler(msg: types.Message):
    if not await is_subscribed(msg.from_user.id):
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©", url=f"https://t.me/{CHANNEL_USERNAME}")]
        ])
        await msg.answer("ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª.", reply_markup=keyboard)
        return
    await msg.answer("ğŸ‘‹ Ù…Ø±Ø­Ø¨Ù‹Ø§! Ø§Ø³Ø£Ù„Ù†ÙŠ Ø£ÙŠ Ø´ÙŠØ¡ ÙÙŠ Ø§Ù„Ø£Ù…Ù† Ø§Ù„Ø³ÙŠØ¨Ø±Ø§Ù†ÙŠ ÙˆØ³Ø£Ø¬ÙŠØ¨Ùƒ + Ø£Ø±Ø³Ù„ Ù„Ùƒ Ù…ØµØ§Ø¯Ø± Ù…ÙÙŠØ¯Ø©.\n\nØ§Ø³ØªØ®Ø¯Ù… /sources Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…ØµØ§Ø¯Ø± Ø§Ù„ÙƒØ§Ù…Ù„Ø©.")

@router.message(Command(commands=["sources"]))
async def show_sources(msg: types.Message):
    if not await is_subscribed(msg.from_user.id):
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©", url=f"https://t.me/{CHANNEL_USERNAME}")]
        ])
        await msg.answer("ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø©.", reply_markup=keyboard)
        return

    response = "ğŸ“š *Ø§Ù„Ù…ØµØ§Ø¯Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©:*\n\n"
    for topic, srcs in sources_db.items():
        response += f"ğŸ”¹ *{topic}*\n"
        for s in srcs:
            response += f"- [{s['title']}]({s['url']})\n"
        response += "\n"
    await msg.answer(response)

@router.message()
async def answer_question(msg: types.Message):
    if not await is_subscribed(msg.from_user.id):
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©", url=f"https://t.me/{CHANNEL_USERNAME}")]
        ])
        await msg.answer("ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª.", reply_markup=keyboard)
        return

    question = msg.text.strip()
    topic = find_topic(question)

    try:
        headers = {"Authorization": f"Bearer {OPENAI_API_KEY}"}
        payload = {
            "model": "gpt-4o",
            "messages": [{"role": "user", "content": f"Ø£Ø¬Ø¨ Ø¨Ø´ÙƒÙ„ ØªØ¹Ù„ÙŠÙ…ÙŠ Ø¹Ù†: {question}"}],
            "temperature": 0.7
        }
        async with session.post("https://api.openai.com/v1/chat/completions", headers=headers, json=payload) as resp:
            data = await resp.json()
            answer = data["choices"][0]["message"]["content"]

            response = f"ğŸ’¡ *Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©:*\n{answer.strip()}\n\n"
            if topic and topic in sources_db:
                response += "ğŸ“š *Ù…ØµØ§Ø¯Ø± Ù…ÙÙŠØ¯Ø©:*\n"
                for s in sources_db[topic]:
                    response += f"- [{s['title']}]({s['url']})\n"

            await msg.answer(response)

    except Exception as e:
        await msg.answer(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ OpenAI:\n`{e}`")

async def on_shutdown(app: web.Application):
    await session.close()
    await bot.session.close()

async def main():
    global session
    session = aiohttp.ClientSession()

    app = web.Application()
    SimpleRequestHandler(dispatcher=dp, bot=bot, webhook_path=WEBHOOK_PATH).register(app, WEBHOOK_PATH)
    setup_application(app, dp, bot=bot)

    app.on_shutdown.append(on_shutdown)

    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, WEBAPP_HOST, WEBAPP_PORT)
    await site.start()

    await bot.set_webhook(WEBHOOK_URL)
    print(f"âœ… Webhook Ø´ØºØ§Ù„ Ø¹Ù„Ù‰: {WEBHOOK_URL}")

if __name__ == "__main__":
    asyncio.run(main())
